{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Nyl documentation","text":"<p>Nyl is a flexible configuration management tool for Kubernetes resources that can be used to generate and deploy applications directly or integrate as an ArgoCD ConfigManagementPlugin.</p>"},{"location":"provisional/","title":"Provisional Documentation","text":"<p>Documentation in this section is provisional and may be incomplete, incorrect or fabricated (i.e. describing a potential future state of Nyl).</p>"},{"location":"provisional/concepts/applications/","title":"Applications","text":"<p>An application is an instance of one package that is deployed to a Kubernetes cluster and are in turn defined also in a Nyl package. Packages instantiated as applications may not produce other applications. Applications are usually accompanied by a <code>nyl-deployment.yaml</code> file that defines the top-level templating context for the package(s), such as the secret store.</p> <p>When deploying a package as an application, the package must not generated resources other than applications, as all deployed resources must be owned by an application.</p>"},{"location":"provisional/concepts/deployment/","title":"Deployment","text":"<p>A deployment is where things get together: This is the place where you define the applications that should be deployed to a Kubernetes cluster, which cluster they are being deployed to, as well as sourcing secrets from a secret store. The configuration for a deployment is defined in a <code>nyl-deployment.yaml</code> file.</p> <pre><code>apiVersion: nyl/v1\nkind: Deployment\nspec:\n  secretStores:\n    default:\n      type: Sops\n      path: secrets.yaml\n</code></pre> <p>Spec</p> <ul> <li><code>secrets</code> (array): The secret stores to make available in the templating context of the deployment. Any secrets   need to be injected from these stores into the application values at templating time.</li> </ul>"},{"location":"provisional/configuration/package/","title":"Packages","text":"<p>A package is similar to a Helm chart in that it is a source for Kubernetes resources that can make use of templating to conditionally render resources and inject values into them. Resources generated by packages may make use of Nyl-specific resource kinds that are only available time of resource generation (see the Templating &gt; Resource Kinds section below).</p> <p>Nyl packages can be checked into a source repository in a DRY form, but can be compiled to a bundle (e.g. including other referenced packages or Helm charts) for deployment when needed (e.g. for shipping to an air-gapped environment).</p> <p>Packages may have a <code>nyl-package.yaml</code> file that defines a schema for the package parameters and additional metadata. A package without this file may still accept and use parameters in its templates.</p>"},{"location":"provisional/configuration/package/#example-package","title":"Example package","text":"<p>Let's consider a somewhat contrived example package that generates a stateful secret, passes that value into a Helm chart, and then further passes another secret created by the Helm chart into another Helm chart. This demonstrates how Nyl can be used to manage the lifecycle of resources across multiple packages.</p> Directory structurenyl-package.yamlapp.yaml <pre><code>my-package/\n\u251c\u2500\u2500 nyl-package.yaml\n\u2514\u2500\u2500 app.yaml\n</code></pre> <pre><code># todo\n</code></pre> <pre><code>apiVersion: nyl.io/v1\nkind: StatefulSecret\nname: password\nstringData:\n  PASSWORD: {{ randhex(32) }}\n---\napiVersion: nyl.io/v1\nkind: HelmChart\nname: my-chart\nchart:\n  repository: https://charts.example.com\n  name: my-chart\n  version: 1.0.0\nvalues:\n  password: {{ ref(\"Secret\", \"password\", \"PASSWORD\") }}\n---\napiVersion: nyl.io/v1\nkind: HelmChart\nname: my-other-chart\nchart:\n  repository: https://charts.example.com\n  name: my-other-chart\n  version: 1.0.0\nvalues:\n  sharedSecret: {{ ref(\"Secret:shared-secret.SECRET\") }}\n</code></pre> <p>In this example, the <code>StatefulSecret</code> resource generates a Kubernetes <code>Secret</code> resource with a random 32-character password. If this secret already exists, it will not be updated (only new keys will be added and removed keys will be deleted).</p> <p>We reference that generated secret in the <code>my-chart</code> Helm chart. Until this secret is available in the cluster, the Helm chart will not be rendered.</p> <p>Finally, we reference a secret that we expect to be generated by the <code>my-chart</code> Helm chart in the <code>my-other-chart</code> Helm chart. Again, this will not be rendered until the secret is available in the cluster.</p> Placeholder resources <p>Should Nyl generate a placeholder resource to indicate that there's a dependency on a resource that doesn't exist yet? This would allow for a better way to introspect the reconciliation state of the package.</p>"},{"location":"provisional/resources/bootstrap/","title":"Bootstrapping a Kubernetes cluster with ArgoCD and Nyl","text":""},{"location":"provisional/resources/comparison/","title":"Comparison to native ArgoCD Helm applications","text":"<p>Nyl may look similar to Helm in the sense that it allows for templating YAML files. However, there are some important differences between the two that make Nyl the better choice for defining applications in a GitOps repository.</p>"},{"location":"provisional/resources/comparison/#combining-multiple-helm-charts","title":"Combining multiple Helm charts","text":"<p>An ArgoCD application supports only a single Helm chart. If you need to deploy multiple Helm charts as part of a single application, you would need to create a Helm chart that includes all the other charts. However, this can lead to a complicated setup that is hard to maintain: It either requires you to repeat the same values in multiple places, or all subcharts support <code>globals</code>.</p>"},{"location":"provisional/resources/comparison/#secret-injection","title":"Secret injection","text":"<p>Natively, ArgoCD applications do not support injecting secrets into the Helm chart values. With Nyl, you can connect to a secrets provider and inject secrets into the generated resources or the value of a Helm chart parameter. Your YAML template becomes the glue code for propagating secrets from the point of origin into your Kubernetes cluster and application.</p> <p>In many cases you can work around this limitation by placing a <code>Secret</code> resource into your cluster, either manually or by other means (such as using external-secrets), but this does not cover the use case for Helm charts that require a secret, or more generally, an external parameter, in a place where an existing secret cannot be configured (e.g. either because the chart simply does not support it or because it needs to be in a specific place/format). This is most commonly an issue when deploying third-party applications from Helm charts.</p>"},{"location":"provisional/resources/comparison/#pipelining-between-applications","title":"Pipelining between applications","text":"<p>Nyl supports looking up information in the cluster at time of rendering the resources. This allows for iteratively reconciling resources in the cluster that depend on each other. For example, it is not uncommon to have an application generate a <code>Secret</code> that later needs to be transformed and piped into another Helm chart.</p> <p>Danger</p> <p>When this feature is enabled, Nyl would allow lookups across the entire cluster (or the resources that the ArgoCD service account has access to). This is a powerful feature that can be used to build complex applications, but it also comes with a security risk when a cluster is shared between multiple teams.</p> <p>Todo</p> <p>Explain how this feature works and how to enable it.</p>"},{"location":"provisional/templating/introduction/","title":"Introduction","text":"<p>Nyl uses Jinja2 as a templating engine, and as such is slightly different from Helm.</p>"},{"location":"provisional/templating/secrets/","title":"Secret injection","text":"<p>Danger</p> <p>When using secret injection with Nyl, you must make sure that you are aware of the risk profile for unintentionally revealing a secret in ArgoCD, which only masks out the data for actual Kubernetes <code>Secret</code> resources. Any other resource that contains the secret will be rendered in plain text.</p> <p>Secrets are only available at the deployment level and need to be propagated further down.</p> <pre><code>apiVersion: nyl/v1\nkind: Application\nmetadata:\n  name: my-app\nspec:\n  package: ./path/to/package\n  values:\n    theSecret: {{ Secrets.default.get(\"my-secret\") }}\n</code></pre>"},{"location":"provisional/templating/resources/HelmChart/","title":"HelmChart","text":"<p>This resource can be used to instantiate Helm charts as part of a package.</p> <pre><code>apiVersion: templating.nyl/v1\nkind: HelmChart\nspec:\n  repository: https://kubernetes.github.io/ingress-nginx\n  chart: ingress-nginx\n  version: 4.10.1\n  releaseName: ingress-nginx\n  releaseNamespace: ingress-nginx\n  values: {}\n</code></pre> <p>Spec</p> <ul> <li><code>repository</code> (string): The Helm repository URL, OCI registry URL (sans the chart name), a local path or a   Git repository clone URL.</li> <li><code>chart</code> (string): The name of the chart in the repository, the chart name to append to the OCI registry URL,   the name of the chart in the local path or the path to the chart in the Git repository.</li> <li><code>version</code> (string): The version of the chart to use. Only relevant for Helm/OCI repositories.</li> <li><code>releaseName</code> (string): The name of the Helm release.</li> <li><code>releaseNamespace</code> (string): The namespace to install the Helm release into. If any resources generated by the   chart have no <code>metadata.namespace</code> field, it will be set to this value.</li> <li><code>values</code> (object): The values to pass to the Helm chart.</li> </ul>"},{"location":"provisional/templating/resources/Package/","title":"Package","text":"<p>Use this resource to instantiate another package.</p> <pre><code>apiVersion: templating.nyl/v1\nkind: Package\nspec:\n  package: ./path/to/package\n  values: {}\n</code></pre> <p>Spec</p> <ul> <li><code>package</code> (string): The path to the package to instantiate. Must be prefixed with <code>./</code> to be resolved relative   to the package that references it. Otherwise, it will be resolved in a search path that is defined in the   <code>nyl-deployment.yaml</code> file.</li> <li><code>values</code> (object): The values to pass to the package.</li> </ul>"},{"location":"reference/applysets/","title":"ApplySets","text":"<p>Kubernetes ApplySets are a method of managing groups of Kubernetes resources for safely applying and pruning resources in a cluster. Nyl provides basic support for ApplySets, allowing you to keep track of deployed resources and prune resources as they are removed from your configuration.</p> <p>Note that ApplySet support is experimental and has still has various issues. You can following the progress of the feature in the nyl#5.</p>"},{"location":"reference/argocd-plugin/","title":"ArgoCD Plugin","text":"<p>This page describes Nyl's integration as an ArgoCD ConfigManagementPlugin.</p>"},{"location":"reference/argocd-plugin/#installation","title":"Installation","text":"<p>Config management plugins are installed as additional containers to the <code>argocd-repo-server</code> Pod. They launch the <code>argocd-cmp-server</code> binary and communicates with ArgoCD over gRPC via a socket file shared between the repo-server and the plugin container under <code>/home/argocd/cmp-server/plugins</code>.</p> <p>We recommend the following configuration:</p> argocd-values.yaml<pre><code>repoServer:\n  extraContainers:\n    - name: nyl-v1\n      image: ghcr.io/niklasrosenstein/nyl/argocd-cmp:{{ NYL_VERSION }}\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 999\n      volumeMounts:\n        - mountPath: /var/run/argocd\n          name: var-files\n        - mountPath: /home/argocd/cmp-server/plugins\n          name: plugins\n        - mountPath: /tmp\n          name: cmp-tmp\n      envFrom:\n        - secretRef:\n            name: argocd-nyl-env\n      env:\n        - name: NYL_CACHE_DIR\n          value: /tmp/nyl-cache\n        - name: NYL_LOG_LEVEL\n          value: info\n  clusterRoleRules:\n    enabled: true\n  volumes:\n    - name: cmp-tmp\n      emptyDir: {}\n</code></pre> <p>Warning</p> <p>The <code>clusterRoleRules.enabled=true</code> option enables the plugin to access the Kubernetes API. This is necessary for various Nyl features to function correctly (such as lookups, see Cluster connectivity). If you do not wish to grant the plugin access to the Kubernetes API, you must disable this option and ensure that your manifests do not rely on features that require API access.</p>"},{"location":"reference/argocd-plugin/#discovery","title":"Discovery","text":"<p>The ArgoCD plugin runs <code>nyl argocd discovery</code> as the discovery command to determine if a repository is compatible with Nyl. This means that if you create an ArgoCD application that points to a Git repository with at least one Nyl configuration file in it, the plugin will be invoked implicitly without specifying the <code>nyl-v1</code> plugin name in the application spec.</p>"},{"location":"reference/argocd-plugin/#one-file-per-application","title":"One file per application","text":"<p>ArgoCD applications do not permit to point their <code>source.path</code> field to a file within a repository, it must be a directory. For this, Nyl accepts a <code>ARGOCD_ENV_NYL_CMP_TEMPLATE_INPUT</code> environment variable that can be a comma-separate list of filenames that you would pass to <code>nyl template</code> as arguments. Nyl will then ignore the default <code>.</code> argument (pointing to the current directory, which is the directory specified with <code>source.path</code>) and use the files specified via the environment variable instead.</p> argocd-application.yaml<pre><code># trimmed example\nspec:\n  source:\n    plugin:\n      name: nyl-v1\n      env:\n        - name: NYL_CMP_TEMPLATE_INPUT\n          value: '{{.path.filename}}'\n</code></pre>"},{"location":"reference/argocd-plugin/#applicationset-example","title":"ApplicationSet example","text":"<p>A desirable pattern for using Nyl with ArgoCD is to create on application per YAML file in the directory corresponding to your cluster in the repository. The following example demonstrates how to setup an ArgoCD <code>ApplicationSet</code> that does exactly this:</p> appset.yaml<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: main\n  namespace: argocd\nspec:\n  goTemplate: true\n  goTemplateOptions: [\"missingkey=error\"]\n  generators:\n  - git:\n      repoURL: git@github.com:myorg/gitops.git\n      revision: HEAD\n      files:\n        - path: \"clusters/my-cluster/*.yaml\"\n  template:\n    metadata:\n      name: '{{.path.filename | trimSuffix \".yaml\" | slugify }}'\n    spec:\n      project: default\n      source:\n        repoURL: git@github.com:myorg/gitops.git\n        targetRevision: HEAD\n        path: '{{.path.path}}'\n        plugin:\n          name: nyl-v1\n          env:\n            - name: NYL_CMP_TEMPLATE_INPUT\n              value: '{{.path.filename}}'\n      destination:\n        server: https://kubernetes.default.svc\n        namespace: '{{.path.basename}}'\n      syncPolicy:\n        syncOptions:\n          - CreateNamespace=true\n          - ServerSideApply=true\n</code></pre> <p>You may treat <code>appset.yaml</code> as a member of the same directory, allowing it to be managed by its own \"appset\" application created by the <code>ApplicationSet</code> itself.</p> <p>Note that in order for the <code>argocd-applicationset-controller</code> to be able to clone your Git repository via SSH, you need to configure a Credential template that matches the <code>spec.generators[0].git.repoURL</code> field, whereas for the individual applications to clone the repository you need to configure a Repository.</p> repository-secrets.yaml<pre><code># For the ApplicationSet\n---\nkind: Secret\nmetadata:\n  name: github-creds\n  namespace: argocd\n  labels:\n    argocd.argoproj.io/secret-type: repo-creds\ntype: Opaque\nstringData:\n  project: default\n  name: github.com\n  url: git@github.com:myorg/\n  type: git\n  sshPrivateKey: ...\n\n# For the Application(s), but credentials can be omitted as they are inherited from the repo-creds above.\n---\nkind: Secret\nmetadata:\n  name: github-repo-gitops\n  namespace: argocd\n  labels:\n    argocd.argoproj.io/secret-type: repository\ntype: Opaque\nstringData:\n  project: default\n  type: git\n  url: git@github.com:myorg/gitops.git\n</code></pre>"},{"location":"reference/argocd-plugin/#debugging-the-plugin","title":"Debugging the plugin","text":"<p>The ArgoCD plugin produces per-project/application logs in the <code>/var/log</code> directory of the <code>nyl-v1</code> container in the <code>argocd-repo-server</code> pod. These logs are often much easier to inspect than the output the template rendering fails and ArgoCD reports stderr to the UI.</p> <p>At the start of each invokation of Nyl, the command will debug-log some useful basic information:</p> <ul> <li>The command-line used to invoke Nyl.</li> <li>The current working directory.</li> <li>All Nyl-relevant environment variables (such that start with <code>ARGOCD_</code>, <code>NYL_</code> and <code>KUBE_</code>).</li> </ul> <p>At the end Nyl will also print the command-line again as well as the time it took for the command to complete. Note that in order to see these logs you should set the <code>NYL_LOG_LEVEL</code> environment variable to <code>debug</code>.</p>"},{"location":"reference/cluster-connectivity/","title":"Cluster connectivity","text":"<p>Nyl may need to reach out to the Kubernetes API for various reasons, some of which are fundamental and others are optional.</p> <p>When using Nyl as an ArgoCD plugin, to enable the plugin to reach out to the Kubernetes API, you must configure the <code>argocd-repo-server</code> service account with the necessary permissions. See ArgoCD Plugin for more information.</p>"},{"location":"reference/cluster-connectivity/#kubernetes-api-versions","title":"Kubernetes API versions","text":"<p>When Nyl invokes <code>helm template</code>, it must pass along a full list of all available API versions in the cluster to allow the chart to generate appropriate manifests for all the latest resources it supports via the <code>--api-versions</code> and <code>--kube-version</code> flags.</p> <p>Note that when used from ArgoCD, the <code>KUBE_VERSION</code> and <code>KUBE_API_VERSIONS</code> environment variables are set by ArgoCD and Nyl will use them if available to avoid making an extra query to the Kubernetes API server. For more information, see ArgoCD Build Environment.</p>"},{"location":"reference/cluster-connectivity/#lookups","title":"Lookups","text":"<p>Nyl provides a <code>lookup()</code> function that allows the Helm chart to query the Kubernetes API server for an existing resource to use in the chart. This is an optional feature that your manifests may simply decide not to rely on, however it is a powerful feature to pass and transform values from existing resources.</p> <p>TODO: Implement security to prevent lookups for resources that the corresponding ArgoCD project has no access to. This will require a safe evaluation language instead of Python <code>eval()</code>.</p>"},{"location":"reference/components/","title":"Components","text":"<p>Nyl components are effectively templates that you can instantiate them similar to standard Kubernetes resources. They are treated in a way similar to CRDs, only that they will never to pushed to the Kubernetes API server and instead be replaced throuhg a first reconcilation phase during <code>nyl template</code>.</p>"},{"location":"reference/components/#how-nyl-looks-for-components","title":"How Nyl looks for components","text":"<p>Nyl by default looks for components in a <code>components/</code> directory relative to your <code>nyl-project.yaml</code> (or relative to your current working directory if there is no <code>nyl-project.yaml</code>). You can also override the path where Nyl looks in the <code>nyl-project.yaml</code>:</p> nyl-project.yaml<pre><code>components_path: ../../components\n</code></pre>"},{"location":"reference/components/#component-directory-structure","title":"Component directory structure","text":"<p>A component must exist in a directory relative to the <code>components_path</code> in a path formatted as <code>{apiVersion}/{kind}</code>. Hence, a typical project structure could look like this:</p> <pre><code>/\n    components/\n        example.org/\n            v1/\n                MyComponent/\n                    [component definition]\n    nyl-project.yaml\n    myapp.yaml\n</code></pre> <p>The <code>[component definition]</code> must be a type of component Nyl understands. Currently, it only supports Helm charts.</p>"},{"location":"reference/components/#using-components","title":"Using components","text":"<p>In your application manifests, you can instantiate a component by declaring it similar to a standard Kubernetes resource. Nyl will try to lookup if that component exists and then instantiate it, or otherwise leave the resource untouched.</p> myapp.yaml<pre><code>apiVersion: example.org/v1\nkind: MyComponent\nmetadata:\n    name: mycomponent\nspec:\n    key: value\n</code></pre>"},{"location":"reference/components/#component-resource-metadata","title":"Component resource metadata","text":"<p>The component's <code>metadata</code> field will be passed to the Helm values. This allows forwarding annotations and labels, if any.</p>"},{"location":"reference/components/#tips-tricks","title":"Tips &amp; tricks","text":"<p>You can use <code>nyl new component example.org/v1 MyComponent</code> to create the boilerplate for a new Nyl component. Currently this is synonymous to calling <code>nyl new chart {components_path}/example.org/v1/MyComponent</code>.</p>"},{"location":"reference/environment/","title":"Environment variables","text":"<p>This page summarizes all environment variables that are used by Nyl.</p> <ul> <li><code>NYL_LOG_LEVEL</code> \u2013 The log level to use if <code>--log-level</code> is not specified. Defaults to <code>info</code>. Used by: <code>nyl</code>.</li> <li><code>NYL_PROFILE</code> \u2013 The name of the profile to use as defined in the closest <code>nyl-profiles.yaml</code> or   <code>nyl-project.yaml</code> configuration file. Used by: <code>nyl profile</code>, <code>nyl template</code>, <code>nyl tun</code>.</li> <li><code>NYL_SECRETS</code> \u2013 The name of the secrets provider to use as defined in the closest <code>nyl-secrets.yaml</code> or   <code>nyl-project.yaml</code> configuration file. Used by: <code>nyl secrets</code>, <code>nyl template</code>.</li> <li><code>NYL_STATE_DIR</code> \u2013 The directory where Nyl stores its state, such as current profile data, which may include   fetched Kubeconfig file. Defaults to <code>.nyl</code> relative to the <code>nyl-project.yaml</code> or the current working directory.   Used by: <code>nyl profile</code>, <code>nyl template</code>, <code>nyl tun</code>.</li> <li><code>NYL_CACHE_DIR</code> \u2013 The directory where Nyl stores its cache, such as downloaded Helm charts and cloned   repositories. Defaults to <code>cache/</code> relative to the <code>NYL_STATE_DIR</code>. Used by <code>nyl template</code>.</li> <li><code>ARGOCD_ENV_NYL_CMP_TEMPLATE_INPUT</code> \u2014 This variable is only recognized by <code>nyl template</code> when the only positional argument   it receives is <code>.</code> (i.e. the current working directory). The variable should be a comma-separated list of filenames   that should be treated as if the files were passed as arguments to <code>nyl template</code> instead. This is used for the Nyl   ArgoCD plugin to allow specifying exactly which files should be templated as part of an ArgoCD application.</li> <li><code>KUBE_VERSION</code> \u2013 The version of the Kubernetes cluster. If this is not set, Nyl will try to query the Kubernetes   API server to determine the version. When used as an ArgoCD plugin, this variable is usually available   <sup>1</sup>. Used by: <code>nyl template</code>.</li> <li><code>KUBE_API_VERSIONS</code> \u2013 A comma-separated list of all available API versions in the cluster. If this is not set,   Nyl will try to query the Kubernetes API server to determine the versions. When used as an ArgoCD plugin, this   variable is usually available <sup>1</sup>. Used by: <code>nyl template</code>.</li> </ul> <ol> <li> <p>See ArgoCD Build Environment.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"reference/templating/","title":"Templating","text":"<p>Todo</p> <p>See structured-templates.</p>"},{"location":"reference/configuration/profiles/","title":"Profiles","text":"<p>Profiles allow you to tell Nyl how to connect to a Kubernetes cluster. They work in concert with traditional \"kubeconfig\" and allow you to have a certain level of assurance you are targeting the expected cluster, as well as providing additional connection methods (such as via SSH tunnel).</p> <p>ArgoCD</p> <p>Profiles are not required with ArgoCD, as the target cluster is defined in the ArgoCD application. Having a profile configuration in your repository when deploying with ArgoCD may have unintended consequences for the way Nyl interacts with the target cluster.</p>"},{"location":"reference/configuration/profiles/#configuration","title":"Configuration","text":"<p>Profiles are defined in a <code>nyl-profiles.&lt;ext&gt;</code> file that is located in the current working directory or any of its parent directories. Profiles may also be defined in a Project configuration file, though the file closer to the working directory will take precedence.</p> <p>If no profile configuration is found this way, Nyl will look for a global configuration file in <code>~/.nyl/nyl-profiles.&lt;ext&gt;</code>.</p> <p>As with other configuration file types, the file extension can be <code>.toml</code>, <code>.yaml</code>, or <code>.json</code>.</p> <p>The configuration contains any number of named profiles. When not specified otherwise, Nyl will assume that the profile to use is named <code>default</code>. The profile to use can be overriden by setting the <code>NYL_PROFILE</code> environment variable, or by passing the corresponding CLI option to respective Nyl commands.</p>"},{"location":"reference/configuration/profiles/#profile-definition","title":"Profile definition","text":"<p>A profile describes:</p> <ol> <li>How to obtain the kubeconfig for the target cluster.</li> <li>(Optionally) How to connect to the target cluster via a tunnel.</li> </ol> <p>The tunnel configuration is useful when the target cluster is not directly accessible from the machine running Nyl, for example when the cluster is behind a firewall or on-premises but can be accessed via an SSH jump host.</p>"},{"location":"reference/configuration/profiles/#example","title":"Example","text":"<p>The following example has Nyl fetch the kubeconfig from a remote machine via SSH, then open an SSH tunnel to the same machine and use that to connect to the Kubernetes cluster.</p> TOMLYAMLJSON nyl-profile.toml<pre><code>[default.kubeconfig]\ntype = \"ssh\"\nuser = \"root\"\nhost = \"mycluster.example.com\"\npath = \"/etc/rancher/k3s/k3s.yaml\"\n\n[default.tunnel]\ntype = \"ssh\"\nuser = \"root\"\nhost = \"mycluster.example.com\"\n</code></pre> nyl-profile.yaml<pre><code>default:\n  kubeconfig:\n    type: ssh\n    user: root\n    host: mycluster.example.com\n    path: /etc/rancher/k3s/k3s.yaml\n  tunnel:\n    type: ssh\n    user: root\n    host: mycluster.example.com\n</code></pre> nyl-profile.json<pre><code>{\n  \"default\": {\n    \"kubeconfig\": {\n      \"type\": \"ssh\",\n      \"user\": \"root\",\n      \"host\": \"mycluster.example.com\",\n      \"path\": \"/etc/rancher/k3s/k3s.yaml\"\n    },\n    \"tunnel\": {\n      \"type\": \"ssh\",\n      \"user\": \"root\",\n      \"host\": \"mycluster.example.com\"\n    }\n}\n</code></pre> <p>In the following example, the kubeconfig is also fetched via SSH, but the server hostname is replaced with one that is reachable from your local machine.</p> TOMLYAMLJSON nyl-profile.toml<pre><code>[default.kubeconfig]\ntype = \"ssh\"\nuser = \"root\"\nhost = \"mycluster.example.com\"\npath = \"/etc/rancher/k3s/k3s.yaml\"\nreplace_apiserver_hostname = \"mycluster.example.com\"\n</code></pre> nyl-profile.yaml<pre><code>default:\n  kubeconfig:\n    type: ssh\n    user: root\n    host: mycluster.example.com\n    path: /etc/rancher/k3s/k3s.yaml\n    replace_apiserver_hostname: mycluster.example.com\n</code></pre> nyl-profile.json<pre><code>{\n  \"default\": {\n    \"kubeconfig\": {\n      \"type\": \"ssh\",\n      \"user\": \"root\",\n      \"host\": \"mycluster.example.com\",\n      \"path\": \"/etc/rancher/k3s/k3s.yaml\",\n      \"replace_apiserver_hostname\": \"mycluster.example.com\"\n    }\n}\n</code></pre> <p>If you are you are already setup with a kubeconfig file, you can specify the path to the file directly or have it automatically use your <code>~/.kube/config</code> file/<code>KUBECONFIG</code> environment variable. You may specify the context to use from that kubeconfig file which ensures Nyl interacts with the correct cluster, even if your <code>kubectl config get-contexts</code> indicates a different current context.</p> TOMLYAMLJSON nyl-profile.toml<pre><code>[default.kubeconfig]\ntype = \"local\"\ncontext = \"mycluster\"\n</code></pre> nyl-profile.yaml<pre><code>default:\n  kubeconfig:\n    type: local\n    context: mycluster\n</code></pre> nyl-profile.json<pre><code>{\n  \"default\": {\n    \"kubeconfig\": {\n      \"type\": \"local\",\n      \"context\": \"mycluster\"\n    }\n}\n</code></pre> <p>Implementation detail</p> <p>Nyl ensures that the correct context is used when interacting with the target cluster, e.g. when using <code>nyl run -- kubectl</code> or using <code>nyl profile activate</code> by generating a temporary kubeconfig file that is stripped down to include only the specified context. You can use <code>nyl profile get-kubeconfig</code> to retrieve the path of the temporary kubeconfig file.</p>"},{"location":"reference/configuration/profiles/#specification","title":"Specification","text":"<p>Todo</p> <p>Include specification of configuration data model.</p>"},{"location":"reference/configuration/profiles/#using-a-profile","title":"Using a profile","text":"<p>All Nyl commands that interact with the cluster will use the profile specified by the <code>NYL_PROFILE</code> environment variable or the one specified with the respective CLI option. If there is no profile configuration in your environment, Nyl will fall back to the global Kubernetes configuration file (equivalent of having a <code>default</code> profile with <code>type: local</code> and no <code>context</code> specified).</p> <p>You can update your shell by source-ing the output of the <code>nyl profile activate</code> command to set the <code>KUBECONFIG</code> and <code>KUBE_CONFIG_PATH</code> environment variables. (The latter is used for example for the Kubernetes Terraform provider).</p> <pre><code>$ nyl profile activate\nexport KUBECONFIG=/project/path/.nyl/profiles/default/kubeconfig.local\nexport KUBE_CONFIG_PATH=/project/path/.nyl/profiles/default/kubeconfig.local\n$ . &lt;(nyl profile activate)\n</code></pre> Tip: Using Direnv <p>When working in a project, you can use Direnv to automatically set the environment variables when you <code>cd</code> into a directory that contains configuration corresponding to a specific Kubernetes cluster.</p> .envrc<pre><code>export NYL_PROFILE=myprofile\n. &lt;(nyl profile activate)\n</code></pre> <p>If <code>NYL_PROFILE</code> is not set, Nyl will assume the default profile name is <code>default</code>.</p>"},{"location":"reference/configuration/profiles/#tunnel-management","title":"Tunnel management","text":"<p>The Nyl CLI will automatically manage tunnels to the target cluster by proxying through an SSH jump host.  The tunnel will typically remain open unless it is explicitly closed by the user to reduce the overhead of setting up the tunnel for each invocation of Nyl.</p> <p>Tunnels can be managed manually using the <code>nyl tun</code> command. Tunnel state is stored globally in <code>~/.nyl/tunnels/state.json</code>. Note that while you may have multiple <code>nyl-profiles.yaml</code> files on your system, the tunnel state is stored globally, and such is the interaction with <code>nyl tun</code>.</p> <pre><code>nyl tun status               List all known tunnels.\nnyl tun start &lt;profile&gt;      Open a tunnel to the cluster targeted by the profile.\nnyl tun stop [&lt;profile&gt;]     Close all tunnels or the tunnel for a specific profile.\n</code></pre>"},{"location":"reference/configuration/projects/","title":"Projects","text":"<p>A Nyl project is a collection of files that together describe a set of Kubernetes resources that are typically deployed to at least one Kubernetes cluster and source secrets from zero or more secrets provider. Kubernetes resources are defined in YAML files and may be templated using Nyl's structured templating or as Helm charts. Helm charts may be used as Nyl components.</p>"},{"location":"reference/configuration/projects/#configuration","title":"Configuration","text":"<p>Projects are defined in a <code>nyl-project.&lt;ext&gt;</code> file that is located in the current working directory or any of its parent directories. A project configuration file is not required to use Nyl, however it is recommended to set various project settings, such as the search path for Helm charts and Nyl components, whether to generate Nyl ApplySets, etc.</p> <p>A project configuration file may also contain the configuration for secrets providers and profiles, though if any configuration file closer to the current working directory for secrets providers or profiles is found, it will take precedence.</p>"},{"location":"reference/configuration/projects/#example","title":"Example","text":"<p>The following example demonstrates a simple project configuration file that sets the search path for Helm charts and Nyl components, enables the generation of ApplySets, and defines a default secrets provider.</p> nyl-project.toml<pre><code>[settings]\ngenerate_applysets = true\nsearch_path = [\"packages\"]\n\n[profiles.default.kubeconfig]\ntype = \"local\"\ncontext = \"my-cluster\"\n\n[secrets.default]\ntype = \"sops\"\npath = \"secrets.yaml\"\n</code></pre>"},{"location":"reference/configuration/projects/#project-structure","title":"Project structure","text":"<p>Nyl is not too opinionated about the project structure, but it was built with support for a certain structure in mind. The following is a suggestion for how to structure your project.</p>"},{"location":"reference/configuration/projects/#homogenous-targets","title":"Homogenous targets","text":"<p>With mostly homogenous clusters (e.g. referencing the same secrets, local helm charts, etc.), a typical project structure may have all Nyl configuration files at the top-level.</p> <p>If you're using ArgoCD, it's also common to further organize the cluster-specific configuration files in ArgoCD project-specific directories. We recommend to self-manage ArgoCD only from the <code>default</code> project.</p> <pre><code>clusters/\n\u2514\u2500\u2500 my-cluster/\n    \u251c\u2500\u2500 .envrc\n    \u251c\u2500\u2500 default/\n    \u2502   \u2514\u2500\u2500 argocd.yaml\n    \u2514\u2500\u2500 main-project/\n        \u2514\u2500\u2500 myapp.yaml\ncomponents/\nnyl-project.toml\n</code></pre> <p>Further reading</p> <ul> <li>Components</li> <li>ArgoCD ApplicationSet Example</li> </ul>"},{"location":"reference/configuration/projects/#heterogenous-targets","title":"Heterogenous targets","text":"<p>For more complex projects with multiple clusters that all look very different and reference differnt secrets, etc., you may want to move your Nyl configuration files closer to the cluster-specific configuration.</p> <pre><code>clusters/\n\u2514\u2500\u2500 main-cluster/\n\u2502   \u251c\u2500\u2500 .envrc\n\u2502   \u251c\u2500\u2500 default/\n\u2502   \u2502   \u2514\u2500\u2500 argocd.yaml\n\u2502   \u2514\u2500\u2500 project-a/\n\u2502       \u2514\u2500\u2500 myapp.yaml\n\u2514\u2500\u2500 my-other-cluster/\n    \u251c\u2500\u2500 .envrc\n    \u2514\u2500\u2500 project-b/\n        \u2514\u2500\u2500 myapp.yaml\nnyl-project.yaml\n</code></pre> <p>If you're using ARgoCD,  you can image <code>main-cluster</code> containing the ArgoCD instance that also deploys the <code>my-other-cluster</code>.</p>"},{"location":"reference/configuration/secrets/","title":"Secrets","text":"<p>You can connect Nyl with various secret providers to retrieve external or encrypted data that can be used in your templates. This is useful for keeping sensitive data out of your configuration files and ensuring that they are not accidentally committed to a version control system.</p>"},{"location":"reference/configuration/secrets/#configuration","title":"Configuration","text":"<p>Secret providers are configured in a <code>nyl-secrets.&lt;ext&gt;</code> file that is located in the current working directory or any of its parent directories. Secret providers may also be defined in a Project configuration file, though the file closer to the working directory will take precedence.</p> <p>There is no \"global\" way to define a secrets provider, as secrets are considered project-specific.</p> <p>As with other configuration file types, the file extension can be <code>.toml</code>, <code>.yaml</code>, or <code>.json</code>.</p> <p>The configuration contains any number of named secret providers. When not specified otherwise, Nyl will assume that the provider to use is named <code>default</code>. The provider to use can be overriden by passing the corresponding CLI option to respective Nyl commands or by setting the <code>NYL_SECRETS</code> environment variable.</p>"},{"location":"reference/configuration/secrets/#inspecting-secret-providers","title":"Inspecting secret providers","text":"<p>You can inspect secret providers using the <code>nyl secrets</code> command.</p> <pre><code>nyl secrets list            List the keys for all secrets in the provider.\nnyl secrets get &lt;key&gt;       Get the value of a secret as JSON.\n</code></pre>"},{"location":"reference/configuration/secrets/#templating","title":"Templating","text":"<p>Secrets are made available to templates using the <code>secrets.get()</code> function. The function takes a single argument, the key of the secret to retrieve.</p> <p>Example</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: my-secret\ntype: Opaque\nstringData:\n  password: ${{ secrets.get(\"my-password\") }}\n</code></pre>"},{"location":"reference/configuration/secrets/#provider-sops","title":"Provider: Sops","text":"<p>Allows you to retrieve secrets from a Sops encrypted file. For a GitOps workflow, the file must be commited to the same repository to ensure that Nyl has access to it when it is invoked as an ArgoCD Config Management plugin. You also must have the <code>sops</code> program installed.</p> <p>Example</p> TOMLYAMLJSON nyl-secrets.toml<pre><code>[default]\ntype = \"sops\"\npath = \"../secrets.yaml\"\n</code></pre> nyl-secrets.yaml<pre><code>default:\n  type: sops\n  path: ../secrets.yaml\n</code></pre> nyl-secrets.json<pre><code>{\n  \"default\": {\n    \"type\": \"sops\",\n    \"path\": \"../secrets.yaml\"\n  }\n}\n</code></pre> <p>The secrets will be decoded using the <code>sops</code> program, hence all the typical ways to configure Sops and how it decrypts files apply. The <code>path</code> field is relative to the location of the <code>nyl-secrets.yaml</code> file.</p>"},{"location":"reference/configuration-api/profiles/","title":"Profiles API","text":""},{"location":"reference/configuration-api/profiles/#nyl.profiles.config","title":"<code>nyl.profiles.config</code>","text":""},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.KubeconfigFromSsh","title":"<code>KubeconfigFromSsh</code>  <code>dataclass</code>","text":"<p>Represents how to obtain the Kubeconfig from an SSH connection.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.KubeconfigFromSsh.context","title":"<code>context: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The context to use from the Kubeconfig file. If not specified, the current context is used.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.KubeconfigFromSsh.host","title":"<code>host: str</code>  <code>instance-attribute</code>","text":"<p>The remote host to connect to.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.KubeconfigFromSsh.identity_file","title":"<code>identity_file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An SSH private key file to use for authentication.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.KubeconfigFromSsh.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>The path where the Kubeconfig can be retrieved from.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.KubeconfigFromSsh.replace_apiserver_hostname","title":"<code>replace_apiserver_hostname: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Replace the hostname in the apiserver configuration of the Kubeconfig. This is useful for example with K3s when reading reading the <code>/etc/rancher/k3s/k3s.yaml</code> file from a remote host, but the API server in that file is not reachable from the local machine (e.g. because it <code>0.0.0.0</code>).</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.KubeconfigFromSsh.user","title":"<code>user: str</code>  <code>instance-attribute</code>","text":"<p>The username to connect to the remote host with.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.LocalKubeconfig","title":"<code>LocalKubeconfig</code>  <code>dataclass</code>","text":"<p>Use the local Kubeconfig file, either from the default location or a custom path specified in the environment.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.LocalKubeconfig.context","title":"<code>context: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The context to use from the Kubeconfig file. If not specified, the current context is used.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.LocalKubeconfig.path","title":"<code>path: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Path to the Kubernetes configuration file. Relative to the profile configuration file. If not specified, it falls back to the default location (per <code>KUBECONFIG</code> or otherwise <code>~/.kube/config</code>).</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.Profile","title":"<code>Profile</code>  <code>dataclass</code>","text":"<p>Represents a Kubernetes connection profile.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.Profile.kubeconfig","title":"<code>kubeconfig: LocalKubeconfig | KubeconfigFromSsh = field(default_factory=lambda: LocalKubeconfig())</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Describe how the Kubeconfig is to be obtained.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.Profile.tunnel","title":"<code>tunnel: SshTunnel | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Describe how to create an SSH tunnel to reach the Kubernetes cluster API.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.ProfileConfig","title":"<code>ProfileConfig</code>  <code>dataclass</code>","text":""},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.ProfileConfig.load","title":"<code>load(file=None, /, *, cwd=None, required=True)</code>  <code>staticmethod</code>","text":"<p>Load the profiles configuration from the given file or the default file. If the configuration file does not exist, an error is raised unless required is set to <code>False</code>, in which case an empty configuration is returned.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.SshTunnel","title":"<code>SshTunnel</code>  <code>dataclass</code>","text":"<p>Configuration for an SSH tunnel.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.SshTunnel.host","title":"<code>host: str</code>  <code>instance-attribute</code>","text":"<p>The host to tunnel through.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.SshTunnel.identity_file","title":"<code>identity_file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An SSH private key file to use for authentication.</p>"},{"location":"reference/configuration-api/profiles/#nyl.profiles.config.SshTunnel.user","title":"<code>user: str</code>  <code>instance-attribute</code>","text":"<p>The username to connect to the remote host with.</p>"},{"location":"reference/configuration-api/secrets/","title":"Secrets API","text":""},{"location":"reference/configuration-api/secrets/#nyl.secrets.sops","title":"<code>nyl.secrets.sops</code>","text":""},{"location":"reference/configuration-api/secrets/#nyl.secrets.sops.SopsFile","title":"<code>SopsFile</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SecretProvider</code></p> <p>This secrets provider decodes a SOPS-encrypted YAML or JSON file and serves the secrets stored within.</p> <p>Nested structures are supported, and the provider maps them to fully qualified keys using dot notation. The nested structure can be accessed as well, returning the full structure as a JSON object.</p>"},{"location":"reference/configuration-api/secrets/#nyl.secrets.sops.SopsFile.do_not_use_in_prod_only_for_testing_sops_age_key","title":"<code>do_not_use_in_prod_only_for_testing_sops_age_key: str | None = field(default=None, repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The key to use for the <code>--age</code> option of SOPS. This is useful for testing purposes only and should not be used in production.</p>"},{"location":"reference/configuration-api/secrets/#nyl.secrets.sops.SopsFile.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":"<p>The path to the SOPS-encrypted file. This path is resolved relative to the configuration file that the provider is defined in.</p>"}]}