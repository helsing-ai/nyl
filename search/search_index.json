{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Nyl documentation","text":"<p>Nyl is a flexible configuration management tool for Kubernetes resources that can be used to generate and deploy applications directly or integrate as an ArgoCD ConfigManagementPlugin.</p>"},{"location":"configuration/intro/","title":"Introduction","text":"<p>Nyl provides various configuration files to customize different aspects of the application:</p> <ul> <li> <p><code>nyl-profiles.yaml</code> defines the profiles that describe how Nyl can make a connection to your Kubernetes   cluster(s). It is often useful to commit this file into a project's repository to share the configuration with other   team members, but you can also store it in your home directory.</p> <p>\u2192 Read more about Profile configuration files.</p> </li> <li> <p><code>nyl-secrets.yaml</code> is project-specific, as it defines the secret provider where secret values can be sourced from   in your Kubernetes manifests that are processed by Nyl. The secrets configuration is usually tied closely with a   particular deployment environment. Nyl uses the closest configuration file to your project's working directory, hence   this file may also be used to span multiple projects.</p> <p>\u2192 Read more about Secrets configuration files.</p> </li> <li> <p><code>nyl-project.yaml</code>, as the name implies, is project-specific and defines the project's metadata and configuration.   A project may yet span more than a single cluster.</p> <p>\u2192 Read more about Project configuration files.</p> </li> </ul> <p>Nyl works particularly well with Direnv to simplify your workflow, particularly in multi-cluster deployment environments. Use it to set <code>NYL_PROFILE</code> to ensure the right cluster is targeted and run <code>. &lt;(nyl profile activate)</code> to ensure immediate cluster connectivity when changing directories.</p> <p>Note that configuration files may also be formatted as TOML (<code>.toml</code>) or JSON (<code>.json</code>).</p>"},{"location":"configuration/intro/#typical-project-structure","title":"Typical project structure","text":"<p>With mostly homogenous clusters (e.g. referencing the same secrets, local helm charts, etc.), a typical project structure may have all Nyl configuration files at the top-level.</p> <pre><code>clusters/\n\u2514\u2500\u2500 my-cluster/\n    \u251c\u2500\u2500 .envrc\n    \u2514\u2500\u2500 myapp.yaml\nnyl-profiles.yaml\nnyl-project.yaml\nnyl-secrets.yaml\n</code></pre> <p>For more complex projects with multiple clusters that all look very different and reference differnt secrets, etc., you may want to move your Nyl configuration files closer to the cluster-specific configuration.</p> <pre><code>clusters/\n\u251c\u2500\u2500 my-cluster/\n\u2502   \u251c\u2500\u2500 .envrc\n\u2502   \u251c\u2500\u2500 nyl-secrets.yaml\n\u2502   \u2514\u2500\u2500 myapp.yaml\n\u2514\u2500\u2500 my-other-cluster/\n    \u251c\u2500\u2500 .envrc\n    \u251c\u2500\u2500 nyl-secrets.yaml\n    \u2514\u2500\u2500 other-app.yaml\nnyl-profiles.yaml\nnyl-secrets.yaml\n</code></pre>"},{"location":"configuration/profiles/","title":"Profiles","text":"<p>Profiles are a way to define targets for deploying your application directly with Nyl. They are not needed when deploying with ArgoCD, as the target cluster is defined in the ArgoCD application.</p> <p>Profiles are defined in a <code>nyl-profiles.yaml</code> file that is located in the current working directory or any of its parent directories. As a last resort, the file will be searched in <code>~/.nyl/nyl-profiles.yaml</code>.</p> <p>The configuration describes</p> <ol> <li>How to obtain the kubeconfig for the target cluster.</li> <li>How to connect to the target cluster (e.g. via a tunnel).</li> </ol> <p>This is particularly useful for clusters that are not directly accessible from the machine running Nyl, such as on-premises clusters or clusters behind a firewall.</p>"},{"location":"configuration/profiles/#example-profile","title":"Example profile","text":"nyl-profile.yaml<pre><code>default:\n  kubeconfig:\n    type: ssh\n    user: root\n    host: mycluster.example.com\n    path: /etc/rancher/k3s/k3s.yaml\n  tunnel:\n    type: ssh\n    user: root\n    host: mycluster.example.com\n</code></pre> <p>Todo</p> <p>Include specification of configuration data model.</p>"},{"location":"configuration/profiles/#activating-a-profile","title":"Activating a profile","text":"<p>Profiles can be activated using the <code>nyl profile activate</code> command. It fetches the Kubeconfig and opens the SSH tunnel (if any) and prints the <code>KUBECONFIG</code> environment variable that can be used to interact with the target cluster.</p> <pre><code>$ nyl profile activate\nexport KUBECONFIG=/project/path/.nyl/profiles/default/kubeconfig.local\nexport KUBE_CONFIG_PATH=/project/path/.nyl/profiles/default/kubeconfig.local\n</code></pre> <p>The profile name can be omitted, in which case it defaults to the value of the <code>NYL_PROFILE</code> environment variable or the string <code>\"default\"</code>.</p>"},{"location":"configuration/profiles/#tunnel-management","title":"Tunnel management","text":"<p>The Nyl CLI will automatically manage tunnels to the target cluster by proxying through an SSH jump host.  The tunnel will typically remain open unless it is explicitly closed by the user to reduce the overhead of setting up the tunnel for each invocation of Nyl.</p> <p>Tunnels can be managed manually using the <code>nyl tun</code> command. Tunnel state is stored globally in <code>~/.nyl/tunnels/state.json</code>. Note that while you may have multiple <code>nyl-profiles.yaml</code> files on your system, the tunnel state is stored globally, and such is the interaction with <code>nyl tun</code>.</p> <pre><code>nyl tun status               List all known tunnels.\nnyl tun start &lt;profile&gt;      Open a tunnel to the cluster targeted by the profile.\nnyl tun stop [&lt;profile&gt;]     Close all tunnels or the tunnel for a specific profile.\n</code></pre>"},{"location":"configuration/projects/","title":"Project configuration","text":"<p>Todo</p>"},{"location":"configuration/secrets/","title":"Secrets","text":"<p>Note</p> <p>While we call them secrets for simplicity, data retrieved from secret providers must not necessarily be sensitive in nature.</p> <p>The <code>nyl-secrets.yaml</code> file is used to define how to connect to a secret provider and retrieve secrets. The file is located in the current working directory or any of its parent directories. The file is considered project-specific, hence it is not searched in a global configuration directory.</p>"},{"location":"configuration/secrets/#provider-sops","title":"Provider: Sops","text":"<p>Allows you to retrieve secrets from a Sops encrypted file. For a GitOps workflow, the file must be commited to the same repository to ensure that Nyl has access to it when it is invoked as an ArgoCD Config Management plugin. You also must have the <code>sops</code> program installed.</p> <p>Example</p> nyl-secrets.yaml<pre><code>provider: sops\npath: ../secrets.yaml\n</code></pre> <p>The secrets will be decoded using the <code>sops</code> program, hence all the typical ways to configure Sops and how it decrypts files apply. The <code>path</code> field is relative to the location of the <code>nyl-secrets.yaml</code> file.</p> <p>Todo</p> <p>Give a recommendation on how to best configure ArgoCD with a private key for Sops, and how to use the public key for encrypting secrets locally before committing them to the repository.</p>"},{"location":"configuration/secrets/#inspecting-secret-providers","title":"Inspecting secret providers","text":"<p>You can inspect secret providers using the <code>nyl secrets</code> command.</p> <pre><code>nyl secrets list            List the keys for all secrets in the provider.\nnyl secrets get &lt;key&gt;       Get the value of a secret as JSON.\n</code></pre>"},{"location":"configuration/api-reference/profiles/","title":"Profiles","text":""},{"location":"configuration/api-reference/profiles/#nyl.profiles.config","title":"<code>nyl.profiles.config</code>","text":""},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.KubeconfigFromSsh","title":"<code>KubeconfigFromSsh</code>  <code>dataclass</code>","text":"<p>Represents how to obtain the Kubeconfig from an SSH connection.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.KubeconfigFromSsh.context","title":"<code>context: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The context to use from the Kubeconfig file. If not specified, the current context is used.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.KubeconfigFromSsh.host","title":"<code>host: str</code>  <code>instance-attribute</code>","text":"<p>The remote host to connect to.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.KubeconfigFromSsh.identity_file","title":"<code>identity_file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An SSH private key file to use for authentication.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.KubeconfigFromSsh.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>The path where the Kubeconfig can be retrieved from.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.KubeconfigFromSsh.user","title":"<code>user: str</code>  <code>instance-attribute</code>","text":"<p>The username to connect to the remote host with.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.LocalKubeconfig","title":"<code>LocalKubeconfig</code>  <code>dataclass</code>","text":"<p>Use the local Kubeconfig file, either from the default location or a custom path specified in the environment.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.LocalKubeconfig.context","title":"<code>context: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The context to use from the Kubeconfig file. If not specified, the current context is used.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.LocalKubeconfig.path","title":"<code>path: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Path to the Kubernetes configuration file. Relative to the profile configuration file. If not specified, it falls back to the default location (per <code>KUBECONFIG</code> or otherwise <code>~/.kube/config</code>).</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.Profile","title":"<code>Profile</code>  <code>dataclass</code>","text":"<p>Represents a Kubernetes connection profile.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.Profile.kubeconfig","title":"<code>kubeconfig: LocalKubeconfig | KubeconfigFromSsh = field(default_factory=lambda: LocalKubeconfig())</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Describe how the Kubeconfig is to be obtained.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.Profile.tunnel","title":"<code>tunnel: SshTunnel | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Describe how to create an SSH tunnel to reach the Kubernetes cluster API.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.ProfileConfig","title":"<code>ProfileConfig</code>  <code>dataclass</code>","text":""},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.ProfileConfig.load","title":"<code>load(file=None, /, *, required=True)</code>  <code>staticmethod</code>","text":"<p>Load the profiles configuration from the given file or the default file. If the configuration file does not exist, an error is raised unless required is set to <code>False</code>, in which case an empty configuration is returned.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.SshTunnel","title":"<code>SshTunnel</code>  <code>dataclass</code>","text":"<p>Configuration for an SSH tunnel.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.SshTunnel.host","title":"<code>host: str</code>  <code>instance-attribute</code>","text":"<p>The host to tunnel through.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.SshTunnel.identity_file","title":"<code>identity_file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An SSH private key file to use for authentication.</p>"},{"location":"configuration/api-reference/profiles/#nyl.profiles.config.SshTunnel.user","title":"<code>user: str</code>  <code>instance-attribute</code>","text":"<p>The username to connect to the remote host with.</p>"},{"location":"configuration/api-reference/secrets/","title":"Secrets","text":""},{"location":"configuration/api-reference/secrets/#nyl.secrets.sops","title":"<code>nyl.secrets.sops</code>","text":""},{"location":"configuration/api-reference/secrets/#nyl.secrets.sops.SopsFile","title":"<code>SopsFile</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SecretProvider</code></p> <p>This secrets provider decodes a SOPS-encrypted YAML or JSON file and serves the secrets stored within.</p> <p>Nested structures are supported, and the provider maps them to fully qualified keys using dot notation. The nested structure can be accessed as well, returning the full structure as a JSON object.</p>"},{"location":"configuration/api-reference/secrets/#nyl.secrets.sops.SopsFile.do_not_use_in_prod_only_for_testing_sops_age_key","title":"<code>do_not_use_in_prod_only_for_testing_sops_age_key: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The key to use for the <code>--age</code> option of SOPS. This is useful for testing purposes only and should not be used in production.</p>"},{"location":"configuration/api-reference/secrets/#nyl.secrets.sops.SopsFile.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":"<p>The path to the SOPS-encrypted file. This path is resolved relative to the configuration file that the provider is defined in.</p>"},{"location":"provisional/","title":"Provisional Documentation","text":"<p>Documentation in this section is provisional and may be incomplete, incorrect or fabricated (i.e. describing a potential future state of Nyl).</p>"},{"location":"provisional/concepts/applications/","title":"Applications","text":"<p>An application is an instance of one package that is deployed to a Kubernetes cluster and are in turn defined also in a Nyl package. Packages instantiated as applications may not produce other applications. Applications are usually accompanied by a <code>nyl-deployment.yaml</code> file that defines the top-level templating context for the package(s), such as the secret store.</p> <p>When deploying a package as an application, the package must not generated resources other than applications, as all deployed resources must be owned by an application.</p>"},{"location":"provisional/concepts/deployment/","title":"Deployment","text":"<p>A deployment is where things get together: This is the place where you define the applications that should be deployed to a Kubernetes cluster, which cluster they are being deployed to, as well as sourcing secrets from a secret store. The configuration for a deployment is defined in a <code>nyl-deployment.yaml</code> file.</p> <pre><code>apiVersion: nyl/v1\nkind: Deployment\nspec:\n  secretStores:\n    default:\n      type: Sops\n      path: secrets.yaml\n</code></pre> <p>Spec</p> <ul> <li><code>secrets</code> (array): The secret stores to make available in the templating context of the deployment. Any secrets   need to be injected from these stores into the application values at templating time.</li> </ul>"},{"location":"provisional/configuration/package/","title":"Packages","text":"<p>A package is similar to a Helm chart in that it is a source for Kubernetes resources that can make use of templating to conditionally render resources and inject values into them. Resources generated by packages may make use of Nyl-specific resource kinds that are only available time of resource generation (see the Templating &gt; Resource Kinds section below).</p> <p>Nyl packages can be checked into a source repository in a DRY form, but can be compiled to a bundle (e.g. including other referenced packages or Helm charts) for deployment when needed (e.g. for shipping to an air-gapped environment).</p> <p>Packages may have a <code>nyl-package.yaml</code> file that defines a schema for the package parameters and additional metadata. A package without this file may still accept and use parameters in its templates.</p>"},{"location":"provisional/configuration/package/#example-package","title":"Example package","text":"<p>Let's consider a somewhat contrived example package that generates a stateful secret, passes that value into a Helm chart, and then further passes another secret created by the Helm chart into another Helm chart. This demonstrates how Nyl can be used to manage the lifecycle of resources across multiple packages.</p> Directory structurenyl-package.yamlapp.yaml <pre><code>my-package/\n\u251c\u2500\u2500 nyl-package.yaml\n\u2514\u2500\u2500 app.yaml\n</code></pre> <pre><code># todo\n</code></pre> <pre><code>apiVersion: nyl.io/v1\nkind: StatefulSecret\nname: password\nstringData:\n  PASSWORD: {{ randhex(32) }}\n---\napiVersion: nyl.io/v1\nkind: HelmChart\nname: my-chart\nchart:\n  repository: https://charts.example.com\n  name: my-chart\n  version: 1.0.0\nvalues:\n  password: {{ ref(\"Secret\", \"password\", \"PASSWORD\") }}\n---\napiVersion: nyl.io/v1\nkind: HelmChart\nname: my-other-chart\nchart:\n  repository: https://charts.example.com\n  name: my-other-chart\n  version: 1.0.0\nvalues:\n  sharedSecret: {{ ref(\"Secret:shared-secret.SECRET\") }}\n</code></pre> <p>In this example, the <code>StatefulSecret</code> resource generates a Kubernetes <code>Secret</code> resource with a random 32-character password. If this secret already exists, it will not be updated (only new keys will be added and removed keys will be deleted).</p> <p>We reference that generated secret in the <code>my-chart</code> Helm chart. Until this secret is available in the cluster, the Helm chart will not be rendered.</p> <p>Finally, we reference a secret that we expect to be generated by the <code>my-chart</code> Helm chart in the <code>my-other-chart</code> Helm chart. Again, this will not be rendered until the secret is available in the cluster.</p> Placeholder resources <p>Should Nyl generate a placeholder resource to indicate that there's a dependency on a resource that doesn't exist yet? This would allow for a better way to introspect the reconciliation state of the package.</p>"},{"location":"provisional/resources/bootstrap/","title":"Bootstrapping a Kubernetes cluster with ArgoCD and Nyl","text":""},{"location":"provisional/resources/comparison/","title":"Comparison to native ArgoCD Helm applications","text":"<p>Nyl may look similar to Helm in the sense that it allows for templating YAML files. However, there are some important differences between the two that make Nyl the better choice for defining applications in a GitOps repository.</p>"},{"location":"provisional/resources/comparison/#combining-multiple-helm-charts","title":"Combining multiple Helm charts","text":"<p>An ArgoCD application supports only a single Helm chart. If you need to deploy multiple Helm charts as part of a single application, you would need to create a Helm chart that includes all the other charts. However, this can lead to a complicated setup that is hard to maintain: It either requires you to repeat the same values in multiple places, or all subcharts support <code>globals</code>.</p>"},{"location":"provisional/resources/comparison/#secret-injection","title":"Secret injection","text":"<p>Natively, ArgoCD applications do not support injecting secrets into the Helm chart values. With Nyl, you can connect to a secrets provider and inject secrets into the generated resources or the value of a Helm chart parameter. Your YAML template becomes the glue code for propagating secrets from the point of origin into your Kubernetes cluster and application.</p> <p>In many cases you can work around this limitation by placing a <code>Secret</code> resource into your cluster, either manually or by other means (such as using external-secrets), but this does not cover the use case for Helm charts that require a secret, or more generally, an external parameter, in a place where an existing secret cannot be configured (e.g. either because the chart simply does not support it or because it needs to be in a specific place/format). This is most commonly an issue when deploying third-party applications from Helm charts.</p>"},{"location":"provisional/resources/comparison/#pipelining-between-applications","title":"Pipelining between applications","text":"<p>Nyl supports looking up information in the cluster at time of rendering the resources. This allows for iteratively reconciling resources in the cluster that depend on each other. For example, it is not uncommon to have an application generate a <code>Secret</code> that later needs to be transformed and piped into another Helm chart.</p> <p>Danger</p> <p>When this feature is enabled, Nyl would allow lookups across the entire cluster (or the resources that the ArgoCD service account has access to). This is a powerful feature that can be used to build complex applications, but it also comes with a security risk when a cluster is shared between multiple teams.</p> <p>Todo</p> <p>Explain how this feature works and how to enable it.</p>"},{"location":"provisional/templating/introduction/","title":"Introduction","text":"<p>Nyl uses Jinja2 as a templating engine, and as such is slightly different from Helm.</p>"},{"location":"provisional/templating/secrets/","title":"Secret injection","text":"<p>Danger</p> <p>When using secret injection with Nyl, you must make sure that you are aware of the risk profile for unintentionally revealing a secret in ArgoCD, which only masks out the data for actual Kubernetes <code>Secret</code> resources. Any other resource that contains the secret will be rendered in plain text.</p> <p>Secrets are only available at the deployment level and need to be propagated further down.</p> <pre><code>apiVersion: nyl/v1\nkind: Application\nmetadata:\n  name: my-app\nspec:\n  package: ./path/to/package\n  values:\n    theSecret: {{ Secrets.default.get(\"my-secret\") }}\n</code></pre>"},{"location":"provisional/templating/resources/HelmChart/","title":"HelmChart","text":"<p>This resource can be used to instantiate Helm charts as part of a package.</p> <pre><code>apiVersion: templating.nyl/v1\nkind: HelmChart\nspec:\n  repository: https://kubernetes.github.io/ingress-nginx\n  chart: ingress-nginx\n  version: 4.10.1\n  releaseName: ingress-nginx\n  releaseNamespace: ingress-nginx\n  values: {}\n</code></pre> <p>Spec</p> <ul> <li><code>repository</code> (string): The Helm repository URL, OCI registry URL (sans the chart name), a local path or a   Git repository clone URL.</li> <li><code>chart</code> (string): The name of the chart in the repository, the chart name to append to the OCI registry URL,   the name of the chart in the local path or the path to the chart in the Git repository.</li> <li><code>version</code> (string): The version of the chart to use. Only relevant for Helm/OCI repositories.</li> <li><code>releaseName</code> (string): The name of the Helm release.</li> <li><code>releaseNamespace</code> (string): The namespace to install the Helm release into. If any resources generated by the   chart have no <code>metadata.namespace</code> field, it will be set to this value.</li> <li><code>values</code> (object): The values to pass to the Helm chart.</li> </ul>"},{"location":"provisional/templating/resources/Package/","title":"Package","text":"<p>Use this resource to instantiate another package.</p> <pre><code>apiVersion: templating.nyl/v1\nkind: Package\nspec:\n  package: ./path/to/package\n  values: {}\n</code></pre> <p>Spec</p> <ul> <li><code>package</code> (string): The path to the package to instantiate. Must be prefixed with <code>./</code> to be resolved relative   to the package that references it. Otherwise, it will be resolved in a search path that is defined in the   <code>nyl-deployment.yaml</code> file.</li> <li><code>values</code> (object): The values to pass to the package.</li> </ul>"},{"location":"reference/argocd-plugin/","title":"ArgoCD Plugin","text":"<p>This page describes Nyl's integration as an ArgoCD ConfigManagementPlugin.</p>"},{"location":"reference/argocd-plugin/#installation","title":"Installation","text":"<p>Config management plugins are installed as additional containers to the <code>argocd-repo-server</code> Pod. They launch the <code>argocd-cmp-server</code> binary and communicates with ArgoCD over gRPC via a socket file shared between the repo-server and the plugin container under <code>/home/argocd/cmp-server/plugins</code>.</p> <p>We recommend the following configuration:</p> argocd-values.yaml<pre><code>repoServer:\n  extraContainers:\n    - name: nyl-v1\n      image: ghcr.io/niklasrosenstein/nyl/argocd-cmp:{{ NYL_VERSION }}\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 999\n      volumeMounts:\n        - mountPath: /var/run/argocd\n          name: var-files\n        - mountPath: /home/argocd/cmp-server/plugins\n          name: plugins\n        - mountPath: /tmp\n          name: cmp-tmp\n      envFrom:\n        - secretRef:\n            name: argocd-nyl-env\n      env:\n        - name: NYL_CACHE_DIR\n          value: /tmp/nyl-cache\n        - name: NYL_LOG_LEVEL\n          value: info\n  clusterRoleRules:\n    enabled: true\n  volumes:\n    - name: cmp-tmp\n      emptyDir: {}\n</code></pre> <p>Warning</p> <p>The <code>clusterRoleRules.enabled=true</code> option enables the plugin to access the Kubernetes API. This is necessary for various Nyl features to function correctly (such as lookups, see Cluster connectivity). If you do not wish to grant the plugin access to the Kubernetes API, you must disable this option and ensure that your manifests do not rely on features that require API access.</p>"},{"location":"reference/argocd-plugin/#one-file-per-application","title":"One file per application","text":"<p>ArgoCD applications do not permit to point their <code>source.path</code> field to a file within a repository, it must be a directory. For this, Nyl accepts a <code>ARGOCD_ENV_NYL_CMP_TEMPLATE_INPUT</code> environment variable that can be a comma-separate list of filenames that you would pass to <code>nyl template</code> as arguments. Nyl will then ignore the default <code>.</code> argument (pointing to the current directory, which is the directory specified with <code>source.path</code>) and use the files specified via the environment variable instead.</p> argocd-application.yaml<pre><code># trimmed example\nspec:\n  source:\n    plugin:\n      name: nyl-v1\n      env:\n        - name: NYL_CMP_TEMPLATE_INPUT\n          value: '{{.path.filename}}'\n</code></pre>"},{"location":"reference/argocd-plugin/#applicationset-example","title":"ApplicationSet example","text":"<p>A desirable pattern for using Nyl with ArgoCD is to create on application per YAML file in the directory corresponding to your cluster in the repository. The following example demonstrates how to setup an ArgoCD <code>ApplicationSet</code> that does exactly this:</p> appset.yaml<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: main\n  namespace: argocd\nspec:\n  goTemplate: true\n  goTemplateOptions: [\"missingkey=error\"]\n  generators:\n  - git:\n      repoURL: git@github.com:myorg/gitops.git\n      revision: HEAD\n      files:\n        - path: \"clusters/my-cluster/*.yaml\"\n  template:\n    metadata:\n      name: '{{.path.filename | trimSuffix \".yaml\" | slugify }}'\n    spec:\n      project: default\n      source:\n        repoURL: git@github.com:myorg/gitops.git\n        targetRevision: HEAD\n        path: '{{.path.path}}'\n        plugin:\n          name: nyl-v1\n          env:\n            - name: NYL_CMP_TEMPLATE_INPUT\n              value: '{{.path.filename}}'\n      destination:\n        server: https://kubernetes.default.svc\n        namespace: '{{.path.basename}}'\n      syncPolicy:\n        syncOptions:\n          - CreateNamespace=true\n          - ServerSideApply=true\n</code></pre> <p>You may treat <code>appset.yaml</code> as a member of the same directory, allowing it to be managed by its own \"appset\" application created by the <code>ApplicationSet</code> itself.</p> <p>Note that in order for the <code>argocd-applicationset-controller</code> to be able to clone your Git repository via SSH, you need to configure a Credential template that matches the <code>spec.generators[0].git.repoURL</code> field, whereas for the individual applications to clone the repository you need to configure a Repository.</p> repository-secrets.yaml<pre><code># For the ApplicationSet\n---\nkind: Secret\nmetadata:\n  name: github-creds\n  namespace: argocd\n  labels:\n    argocd.argoproj.io/secret-type: repo-creds\ntype: Opaque\nstringData:\n  project: default\n  name: github.com\n  url: git@github.com:myorg/\n  type: git\n  sshPrivateKey: ...\n\n# For the Application(s), but credentials can be omitted as they are inherited from the repo-creds above.\n---\nkind: Secret\nmetadata:\n  name: github-repo-gitops\n  namespace: argocd\n  labels:\n    argocd.argoproj.io/secret-type: repository\ntype: Opaque\nstringData:\n  project: default\n  type: git\n  url: git@github.com:myorg/gitops.git\n</code></pre>"},{"location":"reference/argocd-plugin/#debugging-the-plugin","title":"Debugging the plugin","text":"<p>The ArgoCD plugin produces per-project/application logs in the <code>/var/log</code> directory of the <code>nyl-v1</code> container in the <code>argocd-repo-server</code> pod. These logs are often much easier to inspect than the output the template rendering fails and ArgoCD reports stderr to the UI.</p> <p>At the start of each invokation of Nyl, the command will debug-log some useful basic information:</p> <ul> <li>The command-line used to invoke Nyl.</li> <li>The current working directory.</li> <li>All Nyl-relevant environment variables (such that start with <code>ARGOCD_</code>, <code>NYL_</code> and <code>KUBE_</code>).</li> </ul> <p>At the end Nyl will also print the command-line again as well as the time it took for the command to complete. Note that in order to see these logs you should set the <code>NYL_LOG_LEVEL</code> environment variable to <code>debug</code>.</p>"},{"location":"reference/cluster-connectivity/","title":"Cluster connectivity","text":"<p>Nyl may need to reach out to the Kubernetes API for various reasons, some of which are fundamental and others are optional.</p> <p>When using Nyl as an ArgoCD plugin, to enable the plugin to reach out to the Kubernetes API, you must configure the <code>argocd-repo-server</code> service account with the necessary permissions. See ArgoCD Plugin for more information.</p>"},{"location":"reference/cluster-connectivity/#kubernetes-api-versions","title":"Kubernetes API versions","text":"<p>When Nyl invokes <code>helm template</code>, it must pass along a full list of all available API versions in the cluster to allow the chart to generate appropriate manifests for all the latest resources it supports via the <code>--api-versions</code> and <code>--kube-version</code> flags.</p> <p>Note that when used from ArgoCD, the <code>KUBE_VERSION</code> and <code>KUBE_API_VERSIONS</code> environment variables are set by ArgoCD and Nyl will use them if available to avoid making an extra query to the Kubernetes API server. For more information, see ArgoCD Build Environment.</p>"},{"location":"reference/cluster-connectivity/#lookups","title":"Lookups","text":"<p>Nyl provides a <code>lookup()</code> function that allows the Helm chart to query the Kubernetes API server for an existing resource to use in the chart. This is an optional feature that your manifests may simply decide not to rely on, however it is a powerful feature to pass and transform values from existing resources.</p> <p>TODO: Implement security to prevent lookups for resources that the corresponding ArgoCD project has no access to. This will require a safe evaluation language instead of Python <code>eval()</code>.</p>"},{"location":"reference/environment/","title":"Environment variables","text":"<p>This page summarizes all environment variables that are used by Nyl.</p> <ul> <li><code>NYL_LOG_LEVEL</code> \u2013 The log level to use if <code>--log-level</code> is not specified. Defaults to <code>info</code>. Used by: <code>nyl</code>.</li> <li><code>NYL_PROFILE</code> \u2013 The name of the profile to use as defined in the closest <code>nyl-profiles.yaml</code> configuration file.   Used by: <code>nyl profile</code>, <code>nyl template</code>, <code>nyl tun</code>.</li> <li><code>NYL_STATE_DIR</code> \u2013 The directory where Nyl stores its state, such as current profile data, which may include   fetched Kubeconfig file. Defaults to <code>.nyl</code> relative to the <code>nyl-project.yaml</code> or the current working directory.   Used by: <code>nyl profile</code>, <code>nyl template</code>, <code>nyl tun</code>.</li> <li><code>NYL_CACHE_DIR</code> \u2013 The directory where Nyl stores its cache, such as downloaded Helm charts and cloned   repositories. Defaults to <code>cache/</code> relative to the <code>NYL_STATE_DIR</code>. Used by <code>nyl template</code>.</li> <li><code>ARGOCD_ENV_NYL_CMP_TEMPLATE_INPUT</code> \u2014 This variable is only recognized by <code>nyl template</code> when the only positional argument   it receives is <code>.</code> (i.e. the current working directory). The variable should be a comma-separated list of filenames   that should be treated as if the files were passed as arguments to <code>nyl template</code> instead. This is used for the Nyl   ArgoCD plugin to allow specifying exactly which files should be templated as part of an ArgoCD application.</li> <li><code>KUBE_VERSION</code> \u2013 The version of the Kubernetes cluster. If this is not set, Nyl will try to query the Kubernetes   API server to determine the version. When used as an ArgoCD plugin, this variable is usually available   <sup>1</sup>. Used by: <code>nyl template</code>.</li> <li><code>KUBE_API_VERSIONS</code> \u2013 A comma-separated list of all available API versions in the cluster. If this is not set,   Nyl will try to query the Kubernetes API server to determine the versions. When used as an ArgoCD plugin, this   variable is usually available <sup>1</sup>. Used by: <code>nyl template</code>.</li> </ul> <ol> <li> <p>See ArgoCD Build Environment.\u00a0\u21a9\u21a9</p> </li> </ol>"}]}